\graphicspath{{./images/}}      
\def\CHAPTERONE{./chapters/Chapter-1} 

\chapter{Grundlagen}
\label{chap:software}
%	\input{\CHAPTERONE /motivation}

\section{\unreal}
\label{sec:unrealengine}
Die von Epic Games\footnote{\url{https://www.epicgames.com}} entwickelte Unreal Engine\footnote{\url{https://www.unrealengine.com}} ist eine \gls{gameengine} zur Entwicklung von Videospielen und zur Erstellung von filmischen Erfahrungen \cite{featUnreal}. Mittlerweile befindet sich die Unreal Engine in ihrer vierten Generation und enthält nicht nur die \acrshort{engine} selbst, sondern auch eine Vielzahl an Werkzeugen, die alle in die \acrshort{engine} integriert oder angebunden sind, um den Workflow der Nutzer zu vereinfachen und effizienter zu gestalten. Erhältlich ist die \acrshort{engine} für die Betriebssysteme Windows, MacOS und Linux. \par

Im Kern bietet die Unreal Engine eine Möglichkeit zur Echtzeit Manipulation und Erstellung von Anwendungen wie Spielen. Dazu gehören zum Beispiel \gls{fotoreal}, VR Unterstützung und Entwicklung, ein Partikel- und VFX-System, sowie ein KI-System. Weitere Tools umfassen unter anderem einen Animator und einen Sequencer, der zur Erstellung und Editierung von filmischen Sequenzen benutzt werden kann. \par 

Seit Februar 2015 ist der C++ Quellcode der Unreal Engine offen verfügbar und die \acrshort{engine} selber für jeden kostenlos nutzbar, solange kein Gewinn in einer bestimmten Höhe erzielt wird \cite{freeUnreal}. Damit kann jeder an der Entwicklung der \acrshort{engine} teilhaben und sie für die persönlichen Zwecke individualisieren. Zusätzlich können auf dem Marketplace zusätzliche Inhalte und Plugins von Drittanbietern erworben und dann einfach in die \acrshort{engine} integriert werden, wodurch die Unreal Engine ein hohes Maß an Flexibilität und Individualisierung bietet. \par 

Für diese Arbeit interessant ist das \gls{fotoreal} in Echtzeit: die Unreal Engine bietet damit eine Möglichkeit echt wirkende Szenarien zu erstellen, aus denen dann Perzeptionsalgorithmen die Informationen herausfiltern, die für das Trainieren einer KB wichtig sind. Natürlich setzt das voraus, dass die Objekte in der zu rendernden Szene auch realistische Modelle besitzen.     

\subsection{Küchen Umgebung}
\label{subsec:kitchenenvironment}
Um in einer Game Engine ein zu spielendes \textit{Level} (oder \textit{Map}) mit Objekten, mit denen der Spieler interagieren kann, zu füllen, braucht man sogenannte \textit{Assets}. Dies sind 3D-Modelle, die in einem 3D-Modellierungsprogramm erstellt wurden oder 3D-Scans von echten Objekten, die dann in ein passendes Format überführt wurden. Auch wenn im Rahmen dieser Arbeit kein Bedarf besteht, das \textit{Level} zu spielen, werden trotzdem \textit{Assets} benötigt. Diese können dann so angeordnet werden, dass eine Kamera ein Bild von der Szene macht, über das dann die Perzeptionspipeline läuft. \par
Das \gls{iai} besitzt \textit{Assets} für eine realistische Küchenumgebung, die eine Nachbildung einer echten Küche im Institut ist. Sie wird im Rahmen des Projekts \robcog\footnote{\url{http://www.robcog.org/}} ständig verbessert und erweitert. Das Ziel von \robcog ist es Robotern über \textit{Serious Games} mit Commonsense und Wissen über Physik auszustatten. Da bei dem Erstellen und Abnehmen eines Bildes aus der \acrshort{engine} kein Bedarf besteht Schubladen zu öffnen, Objekte anzuheben oder die Herdplatten anzustellen, wird eine Version der Küche benutzt, die auf unnötige Funktionen verzichtet.\footnote{\url{https://github.com/robcog-iai/RobCoG/tree/dev-env}} \par
Die Objekte des täglichen Bedarfs, die im Rahmen dieser Arbeit erkannt werden sollen, sind auch Teil der Küchenumgebung. Es handelt sich bei ihnen um eingescannte echte Objekte, sodass sie einen hohen Detail- und Realitätsgrad besitzen und sich auch vom Roboter auch in der echten Küche finden lassen können.
 
\subsection{URoboVision}
\label{subsec:urobovision}
Damit die Bilder aus der Unreal Engine von der Perzeptionspipline in \robosherlock verarbeitet werden können, wird ein Unreal Engine Plugin verwendet. URoboVision\footnote{\url{https://github.com/robcog-iai/URoboVision}} bietet eine Kamera, die die benötigten Informationen aus der Unreal Engine zieht und dann über eine TCP-Verbindung an \robosherlock schickt. Dazu werden drei Bilder, ein Farbbild, ein Tiefenbild, und eine Objektmaske von der Szene erzeugt. Letzteres ist ein Bild, in dem jedes Objekt in einer anderen Farbe eingefärbt ist. Zusätzlich wird noch eine Map übermittelt, in der jede Farbe ein eindeutiger Objektname zugeordnet ist. Daraus kann später die Groundtruth für Objekthypothesen  ermittelt werden (mehr in \todo{wo ist das?}).   

\subsection{RSpawnBox}
\label{sec:rspawnbox}

Im Rahmen des Bachelor Projekts UnrealRobots im WiSe16/17 SoSe17 der Universität Bremen hat der Autor dieser Arbeit im VisionScanning-Subprojekt\footnote{\url{https://gitlab.informatik.uni-bremen.de/dieckmdo/P12-VisionScanning-UR16} GitLab Account der Universität Bremen notwendig} die RSpawnBox Klasse für die Unreal Engine implementiert. Diese bietet die Möglichkeit ausgewählte Objekte innerhalb einer Bounding Box an zufälligen Plätzen erscheinen zu lassen. Zusätzlich rotierte eine Kamera in anpassbarem Abstand und Winkel um die erschienenen Objekte. Im Rahmen dieser Arbeit wurde letzterer Teil der Klasse in stark modifizierter Form verwendet, um Bilder aus verschiedenen Ansichten der Szene mit der URoboVision Kamera aufzunehmen. Mehr dazu in \todo{wahrscheinlich Implementierung}.         

\section{ROS}
\label{sec:ros}
Das \gls{ros}\footnote{\url{http://www.ros.org}} ist ein quelloffenes, modular designtes \gls{framework} für die Entwicklung von Robotersoftware. \gls{ros} bietet dafür eine Kommunikationsebene über dem Betriebssystem der einzelnen Computer innerhalb eines Robotersystems und eine Menge hilfreicher Werkzeuge an \cite{ros}.\par 

Zu Grunde liegt dem eine Peer-to-Peer Topologie, sodass theoretisch jeder Prozess oder Computer mit jedem anderen kommunizieren kann. Dank eines Programmiersprachen-neutralen Designs ist dies auch über verschiedene Sprachen hinweg kein Problem und ermöglicht so die Berücksichtigung der Bevorzugung bestimmter Sprachen für bestimmte zu implementierende Probleme, wie auch Präferenzen des Entwicklers.\par

Die Kommunikation läuft über sogenannte \textit{Nodes}. Ein Node ist ein Prozess der eine bestimmte Aufgabe bearbeitet. Der Datenaustausch findet nun über \textit{Topics} oder \textit{Services} statt. Beide haben eindeutig identifizierbare Namen und Nodes können sich an ihnen als \textit{Publisher} anmelden oder als \textit{Subscriber} auf sie horchen. Nodes, die als Publisher tätig sind, veröffentlichen nun auf der gegebenem Topic oder Service Daten, während Subscriber die Daten von den entsprechenden Topics oder Services erhalten. Der Unterschied besteht darin, dass Services einmalig sind, während es mehrere Nodes geben kann, die Daten auf einer bestimmten Topic veröffentlichen. Der Austausch von Daten passiert dann in Form von \textit{Messages}. Dies sind feste Datenstrukturen, zum Beispiel die primitiven Datentypen integer und boolean, aber auch Arrays und Messages selbst. \par

\gls{ros} kommt mit einer Reihe von Werkzeugen zur Entwicklung, die in jeweils eigenen Modulen implementiert sind, um so erhöhte Stabilität und verringerte Komplexität zu erreichen. Das Kernmodul, der \textit{ROS-master}, enthält somit nur die Kernfunktionalität. Die zusätzlichen Werkzeuge ermöglichen unter anderem das Debuggen einzelner Nodes, die Visualisierung des Datenaustausches oder einzelner Topics, das Starten ganzer Node-Verbünde und die mehrfach Instanziierung von solchen, sowie das Erstellen von \textit{ROS-Packages}. Letzteres erlaubt das Aufteilen einzelner Funktionalitäten in Pakete und so das einfache Zusammenarbeiten mehrerer Entwickler. Jedes Paket kann jeweils seine eigenen Drittbibliothek-und Paketabhängigkeiten haben, sowie auch auch beliebig tief geschachtelt werden. Ein Paket kann also aus weiteren Paketen bestehen, wie zum Beispiel das im Rahmen dieser Arbeit verwendete \robosherlock [Verweis]. Zum Zeitpunkt dieser Arbeit existieren über 3000 öffentliche ROS-Packages.   

\section{\robosherlock}
\label{sec:robosherlock}
\robosherlock\footnote{\url{http://robosherlock.org/}} ist ein quelloffenes \gls{framework} zur Implementierung von Roboter Perzeptionssystemen. Dabei bietet \robosherlock auch die Möglichkeit, Wissen zu akquirieren und darüber zu Schlussfolgern, als auch Fragen zu der wahrgenommenen Szene zu beantworten. Dabei bekommt der Roboter die Aufgabe nach Objekten einer bestimmten Beschreibung Ausschau zu halten und kann über diese dann zusätzliche Informationen erfahren\cite{robosherlock}. \par
\robosherlock basiert auf der \textit{unstructred information management architecture (UIMA)}\footnote{\url{https://uima.apache.org/}}. Dabei wird davon ausgegangen, dass Daten zwar einer Syntax unterliegen, die Semantik der Daten jedoch unbekannt ist. Ziel ist es nun diese Bedeutung oder das Wissen aus den Daten zu extrahieren. \todo{cite???} Im Falle der Perzeption handelt es sich bei den unstrukturierten Daten um Sensor- und Kameradaten eines Roboters, zum Beispiel Punktwolken oder Farbbilder. Mit \robosherlock können in ihnen nun Hypothesen über potenzielle Objekte innerhalb der wahrgenommenen Szene erstellt werden. \par
Dazu erstellt \robosherlock in einem ersten Schritt eine \textit{\gls{cas}}. Hier werden die initialen Daten der Szene, plus eine Datenstruktur zum Speichern von \textit{Annotationen} und ein \textit{Typsystem} abgespeichert. Annotationen sind die zu einem späteren Zeitpunkt extrahierten Informationen. Das Typsystem sorgt für ein einheitliches Vokabular innerhalb des Systems. \todo{CAS reset every processing loop} \newline
Nun kommen die \textit{\glspl{ae}} zum Einsatz. Dies sind das Herzstück von \robosherlock, da sie die eigentlichen Perzeptionsalgorithmen enthalten, die die Daten analysieren. Diese können in zwei Formen vorliegen: \textit{primitive} und \textit{aggregate}. \par
\textbf{primitive \glspl{ae}} fungieren als Experten für ein spezielles Problem und implementieren jeweils einen speziellen Perzeptionsalgorithmus. Sie können wiederum auch in zwei Arten eingeteilt werden:
\begin{description}
\item[hypotheses generators] analysieren die Daten auf zusammengehörende Strukturen und erstellen Objekthypothesen. Für jede Hypothese wird ein eindeutig identifizierbares \textit{\gls{sofa}} angelegt und zur \gls{cas} hinzugefügt.
\item[Annotatoren] analysieren \glspl{sofa} auf Eigenschaften und Attribute wie zum Beispiel ihre Farbe, Form oder Größe. Die extrahierten Informationen werden als als Annotationen in der \gls{cas} abgespeichert. Sie können während ihrer Analyse auch auf die Annotationen anderer Annotatoren zugreifen.\end{description} Gespeichert werden Annotationen als logische Aussagen der Form 
\begin{displaymath}
\langle attr\text{-}name \rangle (\langle sofa\text{-}id \rangle , \langle attr\text{-}val \rangle)
\end{displaymath}
wobei $\langle$sofa-id$\rangle$ der eindeutige Name des untersuchten \gls{sofa} ist, $\langle$attr-name$\rangle$ ein Attribut des \gls{sofa} und $\langle$attr-val$\rangle$ der Wert des Attributs. Eine Annotation könnte also so Aussehen: 
\begin{displaymath}
color(s1, red)
\end{displaymath}
Beispiele für Annotatoren sind der \textit{ColorClusterHistogrammAnnottator}, dier die Farbe eines Clusters analysiert und \todo{Beispiel}. Die Kapselung der einzelnen Algorithmen macht es möglich neue Perzeptionsalgorithmen in Form von neuen Annotatoren einfach zum System hinzuzufügen. \par
\textbf{aggregate \glspl{ae}} bestehen aus mehreren primitve und aggregate \glspl{ae}. Zusammen mit einem \textit{flow-controller} werden sie zum Perzeptionspipelines, um so mehrere \glspl{ae} auf den selben Daten arbeiten zu zu lassen und komplexere Aufgaben zu lösen. Perzeptionspipelines lassen die \glspl{ae} in einer sequentiell vorher festgelegten Reihenfolge auf den Daten arbeiten. \robosherlock lässt dabei auch Mehrfachannotationen des gleichen Attributs oder Inkonsistenzen beziehungsweise Widersprüche innerhalb der Annotationen zu. Um diese aufzulösen, besitzt \robosherlock eine Engine zum Lernen und Schlussfolgern über Probabilistische First-Order Wissensbasen und speichert dafür zu jeder Annotation, wer sie gemacht und wie sicher er sich dabei war. Die so arbeitenden Experten werden auch Ensemble genannt, das sie sich  genseitig ergänzen und die Schwächen der Anderen ausgleichen können \cite{polikar}.  
  
\subsection{Objektklassifizierer}
\label{sec:classifiers}
Für die Perzeptionspipeline, die im nächsten Kapitel vorgestellt wird \todo{Referenz}, werden Klassifizierer für Form, Klasse und Instanz der Objekte benutzt. Implementiert wurden diese im Rahmen einer Masterarbeit von Rakibul Islam als \robosherlock Annotatorern \cite{rakib}. Der Autor dieser Arbeit hat den Code von einer Abhängigkeit von \textit{OpenCV}\footnote{\url{https://opencv.org/}} 2 zu Version 3 migriert. Zu finden sind die Klassifizierer im \textsc{RoboSherlock}-Package \textit{rs\_addons}\footnote{\url{https://github.com/bbferka/rs\_addons}}. \par
Mit dem \textit{feature\_extractor} werden in einem ersten Schritt mithilfe eines \textit{\gls{vfh}} oder \textit{\gls{cnn}} Merkmale aus den Bildern mit partiellen Sichten\todo{?} der Objekte extrahiert. Dann kann mit den gewonnenen Daten über den \textit{classifier\_trainer} ein Klassifizierer antrainiert werden. Es stehen drei verschiedene Implementationen für sie zur Verfügung: \textit{\gls{rf}}, \textit{\gls{svm}} oder \textit{\gls{knn}}.

\section{\mongodb}
\label{sec:mongodb}
\mongodb\footnote{\url{https://www.mongodb.com/}} ist eine quelloffene und schemafreie Datenbank. Daten werden in \textit{Collections} abgespeichert, die wiederum aus Dokumenten im \gls{bson} Format bestehen. Anders als in Relationalen \textit{Datenbanken} gibt es dabei keine Einschränkungen in welcher Form die Daten gespeichert werden \cite{mongoVsOracle}. Dies wird als schemafrei bezeichnet und passt gut zum Konzept von UIM:
\begin{quote}
"This [...] property nicely fits the paradigms of unstructured information processing, as we can not guarantee that every hypotheses will be annotated in the same way, or that every execution loop generates the same views." \hfill -- \cite{episodicMemory}
\end{quote}
In Dokumenten werden \textit{Schlüssel-Wert-Paare} gespeichert, die jeweils unterschiedliche Datentypen (z.B. Zahlen, Zeichenketten, Arrays und weitere Dokumente) haben können. Beim Anlegen eines neuen Objekts wird ein Feld mit einer eindeutigen Objekt-Id (\textit{\_id}) für den neuen Eintrag angelegt. So kann das Objekt innerhalb der Collection referenziert werden, sowie über Anfragen gefunden werden. Anfragen und Operationen werden in MongoDB nicht klassisch mit \gls{sql} abgesetzt, sondern über eine \textit{Query-Language}. Insgesamt bietet \mongodb als schemafreie Datenbank ein hohe Flexibilität, Geschwindigkeit und Einfachheit \cite{mongoVsOracle}. \todo{Auzug aus DB als Beispiel} \par 
\robosherlock ist in der Lage seine Daten in einer laufenden \mongodb-Instanz zu speichern. Kern ist dabei die \gls{cas} Collection. Diese beinhaltet Referenzen zu den anderen relevanten \textit{views}. Dies sind Daten eines Sensors, wie das \gls{rgb}-Bild oder die Objektmaske. Die \textit{Scenes} Collection enthält Informationen, was \robosherlock zu einem bestimmten Zeitpunkt wahrgenommen hat, unter anderem mit Informationen über den Zeitpunkt, den Viewpoint des Roboters, Objekthypothesen und Annotationen \cite{episodicMemory}.  



\section{Markov Logic Network}
\label{sec:mln}
\glspl{mln} kombinieren die Ausdrucksstärke der \gls{fo} mit der Effizienz von \glspl{pgm}  Unsicherheit und Inkonsistenz zu behandeln und haben deshalb in den letzten Jahren großen Anklang in der Wissenschaft gefunden. Gerade in nicht-deterministischen Umgebungen stoßen \gls{fo} und \gls{pgm} Wissensbasen an ihre Grenzen: \gls{fo} mit seiner Datenbank ähnlichen Repräsentation ist unpraktisch und unzumutbar mit zufälligen Ereignissen umzugehen, während bei \glspl{pgm} die Anzahl an Zufallsvariablen fest ist, die Menge der Variablen zu Beginn jedoch meistens nicht bekannt ist. \cite{nyga17} \par 
Ein \gls{mln} besteht aus einer Menge von Formeln in \gls{fo} (\gls{kb}) und einer Gewichtung für jede Formel. Die möglichen Welten beschreiben alle möglichen Belegungen der Variablen innerhalb einer \gls{kb}. Eine Formel beschreibt einen \textit{Beschränkung oder constraint} auf die eine Teilmenge der Welten. Normalerweise gelten Welten, die eine Formel verletzten, als unmöglich. \glspl{mln} schwächen die constraints nun ab. Welten sind nicht unmöglich sondern weniger wahrscheinlich, wenn die eine Formel verletzen. Die Gewichtung gibt an, wie stark ein constraint ist. Ein höheres Gewicht besagt, dass der Unterschied der Wahrscheinlichkeit zwischen einer Welt, die die Formel erfüllt, und einer Welt, die sie nicht erfüllt, größer ist. Ein \gls{mln} kann nun ein \textit{Markov Netzwerk} aufspannen und somit als Vorlage für die Konstruktion solcher gesehen werden. \cite{mln} \par
Nyga et al. (\cite{pr2looking}) stellen vor, warum \glspl{mln} für die Repräsentation von Wissen und das Reasoning in einem Perzeptionsframework von Vorteil sind: 
\begin{itemize}
	\item \glspl{mln} sind in der Lage die Beziehung zwischen Objekten abzubilden, da sie gleichzeitig eine beliebige aber endliche Menge von Objekten berücksichtigen können.
	\item \glspl{mln} bilden sich ihrer Entscheidung durch die unabhängige Anwendung der Experten und können so Inkonsistenzen kompensieren.
	\item \glspl{mln} können Antworten zu beliebige Anfragen über jeden Aspekt innerhalb des Models liefern. 
	\item indem neue oder zusätzliche Annotationen zu den Objekthypothesen hinzugefügt werden, können diese einfach in ein \gls{mln} integriert werden.    
\end{itemize}   
Für eine ausführlichere Vorstellung von \glspl{pgm}, \gls{fo}, \glspl{mln} und Markov Netzwerken verweise ich den Leser auf \cite{nyga17, mln, jain}. \par 

\textbf{Besispiel:}



\subsection{pracmln}
\label{subsec:pracmln}
